package utils;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import se.miun.dsv.jee.model.LittleKid;
import se.miun.dsv.jee.model.Toy;

public class JdbcDAO {

	
	public boolean addWish(LittleKid kid, List<Toy> toys) {
		Connection connection = ConnectionFactory.getConnection();
	    PreparedStatement ps = null;
	    
	    try {
	          	
	    	connection.setAutoCommit(false);
	    	
	    	//Adding kid to database
	    	ps = connection.prepareStatement("INSERT INTO kids(firstname, lastname, age, howgood) VALUES (?, ?, ?, ?)", Statement.RETURN_GENERATED_KEYS); //spara senaste autogenererade ID:t
	          
	        ps.setString(1, kid.getFirstName());
	        ps.setString(2, kid.getLastName());
	        ps.setInt(3, kid.getAge());
	        ps.setInt(4, kid.getHowGood());
	        
	        //spara ner värde för att senare kontrollera om allt gick bra
	        int first = ps.executeUpdate();
	        
	      //hämta senaste autogenererade ID:t
	        ResultSet autogeneratedkidsKey = ps.getGeneratedKeys(); 
	        autogeneratedkidsKey.next();
	        int kidsKey = autogeneratedkidsKey.getInt(1);
	        
	        autogeneratedkidsKey.close();
	        ps.close();
	       
	        
	        //Lägg in leksaker i databasen (att köra en batch hade varit snyggare men det blir problem med att spara de autogenererade ID:n som jag behöver senare...)
            ps = connection.prepareStatement("INSERT INTO toys(name, manufacturer) VALUES (?, ?)", Statement.RETURN_GENERATED_KEYS);
            
            //spara ner värde i denna för att senare kunna kontrollera att allt gick bra. Sätts initialt till 1 för att senare köras bitwise AND på med senaste executeUpdate(). 
            //Skulle någon uppdatering generera 0 så kommer second för alltid att vara 0 och då indikera att något gick fel.
            int second = 1;       
            
            List<Integer> generatedToyKeys = new ArrayList<Integer>();
            ResultSet toyKeys = null;
            int lastAddedToyKey = 0;
            
            for (Toy toy : toys) {
                ps.setString(1, toy.getName());
                ps.setString(2, toy.getManufacturer());
                second = ps.executeUpdate() & second; //bitwise AND för att kontrollera att alla updates har gått bra
                
                toyKeys = ps.getGeneratedKeys(); 
                toyKeys.next();
                
                lastAddedToyKey = toyKeys.getInt(1);
                generatedToyKeys.add(lastAddedToyKey);
            }        
            
            toyKeys.close();
            ps.close();
            	
            //Lägg in kids-ID och toys-ID i den tredje tabellen dvs. den som beskriver ägandeskap mellan kids och toys 
            ps = connection.prepareStatement("INSERT INTO kids_toys(littlekid_id, toylist_id) VALUES (?, ?)");

            for (int i=0; i<toys.size(); i++) {
                ps.setInt(1, kidsKey);
                ps.setInt(2, generatedToyKeys.get(i));
                ps.addBatch();
            }
            
            int[] third = ps.executeBatch();
            
            //om alla updates har gått bra committas ändringarna
            connection.commit();
            
            ps.close();
            connection.close();           
	        
            if(first == 1 && second == 1 && third.length > 0 ) {
            	return true;
            }
            else {
            	return false;
            }
	    } catch (SQLException ex) {
	    	ex.printStackTrace();
	    	return false;
	    } finally {
	    	if (ps != null) {
	    		try {
	    			ps.close();
	    		} catch (SQLException e) { 
	    			e.printStackTrace();
	    		}
	    	}
	    	if (connection != null) {
	    		try {
	    			connection.close();
	    		} catch (SQLException e) { 
	    			e.printStackTrace();
	    		}
	    	}
	    }

	}
	
	
	public List<LittleKid> getWishes() {
		
	    Connection connection = ConnectionFactory.getConnection();
	    Statement stmt = null;
	    List<LittleKid> kids = new ArrayList<LittleKid>();
        List<Toy> toys = new ArrayList<Toy>();  
        ResultSet rs = null;

	        try {
	            stmt = connection.createStatement();
	            rs = stmt.executeQuery("select k.*, kt.*, t.*  from kids k inner join (select * from kids_toys) kt on k.id = littlekid_id "
	            								+ "inner join (select id as toy_id, manufacturer, name from toys) t on t.toy_id = toylist_id;");
	            int sameKidAgain = -1;
	            
	            int kidId = 0;
                String first = "";
                String last = "";
                int age = 0;
                int howgood = 0;
                int toyId = 0;
                String manufac = "";
                String name = "";
                
                boolean empty = true;
                	            
	            while(rs.next()) {
	            	
	            	empty = false;
	            	
	            	//utförs enbart vid första inläsningen
	            	if(sameKidAgain == -1) {
	            		
	            		sameKidAgain = rs.getInt("id");
	            		
		                kidId = rs.getInt("id");
		                first = rs.getString("firstname");
		                last = rs.getString("lastname");
		                age = rs.getInt("age");
		                howgood = rs.getInt("howgood");
		               
		                toyId = rs.getInt("toy_id");
		                manufac = rs.getString("manufacturer");
		                name = rs.getString("name");
	
	            		toys.add(new Toy(toyId, name, manufac));
	            	}
	            	//om det är en till rad med samma barns id och där bara ytterligare leksaker ska läsas in
	            	else if(rs.getInt("id") == sameKidAgain) {
	            		
	            		sameKidAgain = rs.getInt("id");
	            		
	            		toyId = rs.getInt("toy_id");
		                manufac = rs.getString("manufacturer");
		                name = rs.getString("name");
		                toys.add(new Toy(toyId, name, manufac));
	            	}
	            	//om det inte är första rundan utan dags att läsa in ett nytt barn
	            	else {
	            		
	            		kids.add(new LittleKid(kidId, first, last, age, howgood, toys));            		
	            		
	            		toys = new ArrayList<Toy>();
	            		
	            		sameKidAgain = rs.getInt("id");
	            		
	            		kidId = rs.getInt("id");
		                first = rs.getString("firstname");
		                last = rs.getString("lastname");
		                age = rs.getInt("age");
		                howgood = rs.getInt("howgood");

		                toyId = rs.getInt("toy_id");
		                manufac = rs.getString("manufacturer");
		                name = rs.getString("name");
	
		                toys.add(new Toy(toyId, name, manufac));
	            	}
	                
	            }
	            
	            //lägg till det senast inlästa barnet
	            if(!empty) {
	            	kids.add(new LittleKid(kidId, first, last, age, howgood, toys));
	            }
	            
	            rs.close();
	            stmt.close();
	            connection.close();
	            
	        } catch (SQLException ex) {
	        	ex.printStackTrace();	        	
	        } finally {
	        	if (rs != null) {
	        		try {
	        			rs.close();
	        		} catch (SQLException e) { 
	        			e.printStackTrace();
	        		}
	        	}
	        	if (stmt != null) {
	        		try {
	        			stmt.close();
	        		} catch (SQLException e) { 
	        			e.printStackTrace();
	        		}
	        	}
	        	if (connection != null) {
	        		try {
	        			connection.close();
	        		} catch (SQLException e) { 
	        			e.printStackTrace();
	        		}
	        	}
	        }
	        
	    return kids;
	}
	
}
